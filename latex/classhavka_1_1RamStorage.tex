\hypertarget{classhavka_1_1RamStorage}{}\doxysection{havka\+::Ram\+Storage Class Reference}
\label{classhavka_1_1RamStorage}\index{havka::RamStorage@{havka::RamStorage}}


Implementation of storage interface, uses R\+AM. Thread-\/safe.  




{\ttfamily \#include $<$storage.\+h$>$}



Inheritance diagram for havka\+::Ram\+Storage\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=216pt]{classhavka_1_1RamStorage__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for havka\+::Ram\+Storage\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=216pt]{classhavka_1_1RamStorage__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classhavka_1_1RamStorage_a79d548a4b49d5047f709a8b5400095af}{Ram\+Storage}} (Queue\+Type queue\+Type)
\item 
void \mbox{\hyperlink{classhavka_1_1RamStorage_a18875690e2a8c7afbd91f0108132f4e7}{post\+Message}} (const \mbox{\hyperlink{structhavka_1_1Message}{Message}} \&message, const std\+::string \&tag) override
\item 
std\+::optional$<$ \mbox{\hyperlink{structhavka_1_1Message}{Message}} $>$ \mbox{\hyperlink{classhavka_1_1RamStorage_abba4728c2a65b4038b91c76a2593d53e}{get\+Message\+Nonblocking}} (const std\+::string \&tag) override
\item 
std\+::optional$<$ \mbox{\hyperlink{structhavka_1_1Message}{Message}} $>$ \mbox{\hyperlink{classhavka_1_1RamStorage_aede09d6819ad77422ac9180b75f2f0ad}{get\+Message\+Blocking}} (const std\+::string \&tag, std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classhavka_1_1Connection}{Connection}} $>$ connection) override
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Implementation of storage interface, uses R\+AM. Thread-\/safe. 

Implementation of \mbox{\hyperlink{classhavka_1_1IMessageStorage}{I\+Message\+Storage}} interface with R\+AM unordered maps and mutex. Thread-\/safe because of mutex. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classhavka_1_1RamStorage_a79d548a4b49d5047f709a8b5400095af}\label{classhavka_1_1RamStorage_a79d548a4b49d5047f709a8b5400095af}} 
\index{havka::RamStorage@{havka::RamStorage}!RamStorage@{RamStorage}}
\index{RamStorage@{RamStorage}!havka::RamStorage@{havka::RamStorage}}
\doxysubsubsection{\texorpdfstring{RamStorage()}{RamStorage()}}
{\footnotesize\ttfamily havka\+::\+Ram\+Storage\+::\+Ram\+Storage (\begin{DoxyParamCaption}\item[{Queue\+Type}]{queue\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}}

Initializes storage with exact type of queue used. 
\begin{DoxyParams}{Parameters}
{\em queue\+Type} & queue type to use. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classhavka_1_1RamStorage_aede09d6819ad77422ac9180b75f2f0ad}\label{classhavka_1_1RamStorage_aede09d6819ad77422ac9180b75f2f0ad}} 
\index{havka::RamStorage@{havka::RamStorage}!getMessageBlocking@{getMessageBlocking}}
\index{getMessageBlocking@{getMessageBlocking}!havka::RamStorage@{havka::RamStorage}}
\doxysubsubsection{\texorpdfstring{getMessageBlocking()}{getMessageBlocking()}}
{\footnotesize\ttfamily std\+::optional$<$ \mbox{\hyperlink{structhavka_1_1Message}{Message}} $>$ havka\+::\+Ram\+Storage\+::get\+Message\+Blocking (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{tag,  }\item[{std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classhavka_1_1Connection}{Connection}} $>$}]{connection }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Gets message from the storage. Call is nonblocking. If queue is empty, pushes client to the waiting queue. 
\begin{DoxyParams}{Parameters}
{\em tag} & message topic \\
\hline
{\em connection} & clients connection (which is being pushed to waiting queue if needed) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
message or std\+::nullopt if topic is empty 
\end{DoxyReturn}


Implements \mbox{\hyperlink{classhavka_1_1IMessageStorage_ae2a93f60d0d1e52e6798976a6c403da6}{havka\+::\+I\+Message\+Storage}}.

\mbox{\Hypertarget{classhavka_1_1RamStorage_abba4728c2a65b4038b91c76a2593d53e}\label{classhavka_1_1RamStorage_abba4728c2a65b4038b91c76a2593d53e}} 
\index{havka::RamStorage@{havka::RamStorage}!getMessageNonblocking@{getMessageNonblocking}}
\index{getMessageNonblocking@{getMessageNonblocking}!havka::RamStorage@{havka::RamStorage}}
\doxysubsubsection{\texorpdfstring{getMessageNonblocking()}{getMessageNonblocking()}}
{\footnotesize\ttfamily std\+::optional$<$ \mbox{\hyperlink{structhavka_1_1Message}{Message}} $>$ havka\+::\+Ram\+Storage\+::get\+Message\+Nonblocking (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{tag }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Gets message from the storage. If topic is empty, returns std\+::nullopt Nonblocking. 
\begin{DoxyParams}{Parameters}
{\em tag} & message topic \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
message or std\+::nullopt if topic is empty 
\end{DoxyReturn}


Implements \mbox{\hyperlink{classhavka_1_1IMessageStorage_a26f6449215c3b41cd214cf7e7041c532}{havka\+::\+I\+Message\+Storage}}.

\mbox{\Hypertarget{classhavka_1_1RamStorage_a18875690e2a8c7afbd91f0108132f4e7}\label{classhavka_1_1RamStorage_a18875690e2a8c7afbd91f0108132f4e7}} 
\index{havka::RamStorage@{havka::RamStorage}!postMessage@{postMessage}}
\index{postMessage@{postMessage}!havka::RamStorage@{havka::RamStorage}}
\doxysubsubsection{\texorpdfstring{postMessage()}{postMessage()}}
{\footnotesize\ttfamily void havka\+::\+Ram\+Storage\+::post\+Message (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structhavka_1_1Message}{Message}} \&}]{message,  }\item[{const std\+::string \&}]{tag }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Posts message to the storage. If topic is empty and there are waiting clients, sends message to one of them 
\begin{DoxyParams}{Parameters}
{\em message} & message to post \\
\hline
{\em tag} & message topic \\
\hline
\end{DoxyParams}
there is a waiting client, send message immediately

push message to the queue

Implements \mbox{\hyperlink{classhavka_1_1IMessageStorage_a3f263ce5807a97ecaff6b546d3ca8b0a}{havka\+::\+I\+Message\+Storage}}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/server/storage.\+h\item 
src/server/storage.\+cpp\end{DoxyCompactItemize}
